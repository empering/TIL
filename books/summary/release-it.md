# Release It

> 마이클 나이가드 저. 신승환, 정태중 역. 위키북스. 2007.

## 2장. 사례연구: 항공사를 정지시킨 예외 사건
```java
public List lookupByCity() throws SQLException {
    Connection connection = null;
    Statement statement = null;

    try {
        connectionPool.getConnection();
        statement = connection.createStatement();
    } finally {
        if (statement != null) statement.close();
        if (connection != null) connection.close();
    }
}
```
- 항공사 Core Facilities 사용되는 데이터 베이스 클러스트의 계획된 페일오버 후 2시간쯤 지난 시점에 애플리케이션이 응답을 하지 않음. 이로 인해 항공사의 키오스크들은 정지함.
- 자동화 된 툴을 통해 애플리케이션의 스레드 덤프, 데이터베이스의 스냅샷 등을 수집 후 SLA 제한 시간에 임박하여 서버를 재시작하는 것으로 서비스 복구.
- 사후 파악 결과, 페일 오버 전 JDBC 연결이 생성되었고 계획된 페일오버 간 JDBC 연결을 생성하기 위해 사용 된 IP 주소는 다른 호스트로 변경됐지만 TCP 연결 상태는 변경되지 않았음. 이때 소켓에 무언가를 쓰면 IO 예외 발생. [Connection.close()](https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html#close--) 는 예외를 던질 수 있음.  따라서 예외로 인해 연결을 닫지 못하고 커넥션 풀이 바닥나고 `lookupByCity()` 를 호출하는 스레드는 모두 블록 됨.

## 3장. 안정성 소개
- 엔터프라이즈 소프트웨어는 냉소적이어야 함.
- 냉소적인 소프트웨어는 나쁜 일이 생길 거라 예상하고 그런 일이 생겼을 때 전혀 놀라지 않음.
- 낮은 안정성은 심각한 비용 수반과 더불어 기업의 평판을 잃음.

### 안정성이란
- 지속성을 갖는 시스템은 트랜잭션을 오랫동안 처리함. 여기서 ‘오랫동안’이란 배포 사이클 정도로 생각하면 유용. 매주 새로운 코드가 배포 된다면 2년 동안 시스템 리부팅 없이 실행될 수 있는지 중요하지 않음.
- 여기서 말하는 트랜잭션은 시스템이 처리하는 추상적인 작업 단위를 의미. 예를 들어 전자상거래 사이트에서 ‘고객이 제품을 주문하는 것’. 여러 페이지, 여러 외부 시스템과의 통합, 여러 데이터베이스 트랜잭션등을 포함 할 수 있음.
- 회복력 있는 시스템은 일시적 충격이나 지속적인 스트레스, 정상 처리를 방해하는 부품 고장이 있을 때도 트랜잭션을 계속 처리할 수 있어야 함. 이것이 안정성이 의미하는 바임.

### 시스템 수명 연장하기
- 시스템 수명을 위협하는 주요 위험은 메모리 누수와 데이터 성장.
- 둘 다 테스트 중에 잡아내기 어려움.
- 이런 문제를 발견하는 유일한 방법은 장기 테스트를 실행하는 것.
- 아무런 테스트를 하지 않는다면, 실전 환경에서 장기 테스트를 하는 격.

### 고장 유형
- 스트레스가 가해지면 물체의 형상이 변하는 것을 스트레인이라고 함. 즉 스트레스는 스트레인을 일으킴.
- 갑작스런 충격, 과도한 스트레인으로 인해 시스템의 어떤 부분은 다른 부분보다 먼저 고장나기 시작. 이것을 시스템 크랙이라 함. 
- 최초로 크랙을 일으키는 것, 시스템의 나머지 부분으로 크랙이 전파되는 방식, 그리고 손상된 결과를 합쳐 고장 유형이라 정의.
- 크랙이나 크랙의 전파로부터 시스템의 필수적인 기능에 영향을 미치지 못하도록 고장 유형을 설계 해야 함.

### 크랙 전파
항공사 정지 사건에서 크랙은 SQL 예외를 부적절하게 처리하는데서 발생했지만 다른 많은 지점에서 크랙을 멈출 수 있었음.
- 자원이 고갈되었을 때 더 많은 연결을 생성하도록 풀을 구성.
- 요청자를 영원히 블록하는 대신 제한 된 시간 동안 블록하도록 설정.

한 수준 올려 살펴 보면
- CF 를 호출하는 클라이언트들은 타임아웃을 설정할 수 있었음.
- 또는 블록된 스레드는 버려지도록 호출을 작성할 수 있었음.

좀 더 큰 관점, 더 큰 아키텍처에서 보자면
- CF 자체를 하나 이상의 서비스 그룹을 나눴으면 모든 사용자가 정지하는 대신 서비스 그룹 중 하나만 정지될 수도 있었음.
- CF 를 요청/응답 메시지 큐를 사용해 구축할 수도 있었음.
- CF 는 튜플스페이스에 항공편 기록을 채우고 클라이언트는 튜플스페이스에서 검색 조건에 맞는 항공편을 찾을 수도 있었음.

아키텍처가 더 밀접히 결합 될수록 에러가 전파될 가능성은 더 커짐.

### 고장의 연쇄와 패턴, 안티패턴
- 항공사 정지 사건에서 살펴본 바와 같이 사소한 일이 다른 일을 일으키고, 또 일어난 일은 다른 일을 일으킴.
- 가능한 모든 고장에 대비하는 한 가지 방법은 모든 외부 호출, 모든 입출력, 모든 자원 사용, 모든 예상 결과를 살펴보고 이런 것들이 잘못될 수 있는 방법에는 어떤 것들이 있을지 질문해 보는 것. 하지만 이와 같은 무지막지한 접근 방식은 비현실적.
- 저자는 수백 가지 실전 상황의 고장을 다뤘는데 정확히 고장의 연쇄가 동일한 방식으로 일어났던 적은 없음.
- 그렇지만 어떤 축을 따라 나타나는 취약성, ‘이런’ 문제가 ‘저런’ 방식을 증폭시키는 경향 등의 패턴을 발견 함.
