# Release It

> 마이클 나이가드 저. 신승환, 정태중 역. 위키북스. 2007.

본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.

## 2장. 사례연구: 항공사를 정지시킨 예외 사건
```java
public List lookupByCity() throws SQLException {
    Connection connection = null;
    Statement statement = null;

    try {
        connectionPool.getConnection();
        statement = connection.createStatement();
    } finally {
        if (statement != null) statement.close();
        if (connection != null) connection.close();
    }
}
```
- 항공사 Core Facilities 사용되는 데이터 베이스 클러스트의 계획된 페일오버 후 2시간쯤 지난 시점에 애플리케이션이 응답을 하지 않음. 이로 인해 항공사의 키오스크들은 정지함.
- 자동화 된 툴을 통해 애플리케이션의 스레드 덤프, 데이터베이스의 스냅샷 등을 수집 후 SLA 제한 시간에 임박하여 서버를 재시작하는 것으로 서비스 복구.
- 사후 파악 결과, 페일 오버 전 JDBC 연결이 생성되었고 계획된 페일오버 간 JDBC 연결을 생성하기 위해 사용 된 IP 주소는 다른 호스트로 변경됐지만 TCP 연결 상태는 변경되지 않았음. 이때 소켓에 무언가를 쓰면 IO 예외 발생. [Connection.close()](https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html#close--) 는 예외를 던질 수 있음.  따라서 예외로 인해 연결을 닫지 못하고 커넥션 풀이 바닥나고 `lookupByCity()` 를 호출하는 스레드는 모두 블록 됨.

## 3장. 안정성 소개
- 엔터프라이즈 소프트웨어는 냉소적이어야 함.
- 냉소적인 소프트웨어는 나쁜 일이 생길 거라 예상하고 그런 일이 생겼을 때 전혀 놀라지 않음.
- 낮은 안정성은 심각한 비용 수반과 더불어 기업의 평판을 잃음.

### 안정성이란
- 지속성을 갖는 시스템은 트랜잭션을 오랫동안 처리함. 여기서 ‘오랫동안’이란 배포 사이클 정도로 생각하면 유용. 매주 새로운 코드가 배포 된다면 2년 동안 시스템 리부팅 없이 실행될 수 있는지 중요하지 않음.
- 여기서 말하는 트랜잭션은 시스템이 처리하는 추상적인 작업 단위를 의미. 예를 들어 전자상거래 사이트에서 ‘고객이 제품을 주문하는 것’. 여러 페이지, 여러 외부 시스템과의 통합, 여러 데이터베이스 트랜잭션등을 포함 할 수 있음.
- 회복력 있는 시스템은 일시적 충격이나 지속적인 스트레스, 정상 처리를 방해하는 부품 고장이 있을 때도 트랜잭션을 계속 처리할 수 있어야 함. 이것이 안정성이 의미하는 바임.

### 시스템 수명 연장하기
- 시스템 수명을 위협하는 주요 위험은 메모리 누수와 데이터 성장.
- 둘 다 테스트 중에 잡아내기 어려움.
- 이런 문제를 발견하는 유일한 방법은 장기 테스트를 실행하는 것.
- 아무런 테스트를 하지 않는다면, 실전 환경에서 장기 테스트를 하는 격.

### 고장 유형
- 스트레스가 가해지면 물체의 형상이 변하는 것을 스트레인이라고 함. 즉 스트레스는 스트레인을 일으킴.
- 갑작스런 충격, 과도한 스트레인으로 인해 시스템의 어떤 부분은 다른 부분보다 먼저 고장나기 시작. 이것을 시스템 크랙이라 함. 
- 최초로 크랙을 일으키는 것, 시스템의 나머지 부분으로 크랙이 전파되는 방식, 그리고 손상된 결과를 합쳐 고장 유형이라 정의.
- 크랙이나 크랙의 전파로부터 시스템의 필수적인 기능에 영향을 미치지 못하도록 고장 유형을 설계 해야 함.

### 크랙 전파
항공사 정지 사건에서 크랙은 SQL 예외를 부적절하게 처리하는데서 발생했지만 다른 많은 지점에서 크랙을 멈출 수 있었음.
- 자원이 고갈되었을 때 더 많은 연결을 생성하도록 풀을 구성.
- 요청자를 영원히 블록하는 대신 제한 된 시간 동안 블록하도록 설정.

한 수준 올려 살펴 보면
- CF 를 호출하는 클라이언트들은 타임아웃을 설정할 수 있었음.
- 또는 블록된 스레드는 버려지도록 호출을 작성할 수 있었음.

좀 더 큰 관점, 더 큰 아키텍처에서 보자면
- CF 자체를 하나 이상의 서비스 그룹을 나눴으면 모든 사용자가 정지하는 대신 서비스 그룹 중 하나만 정지될 수도 있었음.
- CF 를 요청/응답 메시지 큐를 사용해 구축할 수도 있었음.
- CF 는 튜플스페이스에 항공편 기록을 채우고 클라이언트는 튜플스페이스에서 검색 조건에 맞는 항공편을 찾을 수도 있었음.

아키텍처가 더 밀접히 결합 될수록 에러가 전파될 가능성은 더 커짐.

### 고장의 연쇄와 패턴, 안티패턴
- 항공사 정지 사건에서 살펴본 바와 같이 사소한 일이 다른 일을 일으키고, 또 일어난 일은 다른 일을 일으킴.
- 가능한 모든 고장에 대비하는 한 가지 방법은 모든 외부 호출, 모든 입출력, 모든 자원 사용, 모든 예상 결과를 살펴보고 이런 것들이 잘못될 수 있는 방법에는 어떤 것들이 있을지 질문해 보는 것. 하지만 이와 같은 무지막지한 접근 방식은 비현실적.
- 저자는 수백 가지 실전 상황의 고장을 다뤘는데 정확히 고장의 연쇄가 동일한 방식으로 일어났던 적은 없음.
- 그렇지만 어떤 축을 따라 나타나는 취약성, ‘이런’ 문제가 ‘저런’ 방식을 증폭시키는 경향 등의 패턴을 발견 함.


## 4장. 안정성 안티패턴
### 통합지점
- 애플리케이션의 범위는 폭발적으로 늘어났고 처음에는 회사 안에서, 이제는 회사를 넘나들며 통합 하고 있음.
- 반면 모든 소켓, 프로세스, 원격프로시저, 데이터베이스 등의 호출은 시스템에 행이 걸리게 하거나, 충돌시키거나, 다른 충격을 만들 수 있음.

> 통합 지점은 시스템을 살해하는 최고의 킬러.

#### 소켓 기반 프로토콜
- 많은 상위 수준의 통합 프로토콜은 소켓 위에서 작동.
- 상위 수준의 프로토콜에는 고유한 고장 유형이 있지만, 이런 프로토콜은 또한 소켓 계층에서 발생한 고장에 영향을 받기 쉬움.
- 클라이언트 시스템은 연결 실패를 반드시 처리해야 하며 OS 수준의 연결 제한시간도 확인해야 함.
- 네트워크 고장은 두 가지 방식으로 우리를 공격할 수 있음. (1) 빠른 방식과 (2) 느린 방식
- 빠른 방식은 호출하는 코드에서 즉각적으로 예외를 일으킴. 예컨대, 연결 거부.
- 느린 고장은 예외를 던지기 전까지 스레드를 몇 분 정도 블록. 블록된 스레드로 전체 처리량이 떨어지고 모든 스레드가 블록된다면 서버는 멈춤. 예컨대, 손실된 ACK.
- 저자는 느린 응답은 응답이 없는 것보다 나쁘다고 말함.

##### 사례 연구: 새벽 5시 문제
- 매일 새벽 5시, 모든 서버가 완전히 행이 걸리는 증상이 반복적으로 발생.
- 스레드 덤프를 통해 JDBC 라이브러리 안에서 스레드가 블록된 것을 확인하고 tcpdump 를 통해 DB 서버로 많은 패킷이 보내졌지만 응답은 없었다는 것을 확인.
- 원인은 방화벽 안의 수립 된 연결을 기록한 테이블. 테이블은 유한하고 어떤 연결이 패킷 송수신 없이 오랜 시간이 흐르면 테이블에서 연결을 삭제. 이후 해당 연결에서 들어오는 SYN 패킷을 버림.
- 트래픽이 급증할 때, 양 끝의 서버들은 반만 열린 소켓 (half-open socket) 으로 인해 클라이언트 서버의 리소스 풀이 고갈.

#### 벤더 API 라이브러리
- 라이브러리에서 가장 최악인 점은 우리가 라이브러리를 거의 제어할 수 없다는 점.
- 라이브러리 역시 평범한 개발자들이 만든 코드이며 품질, 스타일, 안정성에서 다양성을 보여줌. 안정성을 해치는 가장 큰 문제는 대부분 블로킹에 관한 것.
- 저자가 전달하고자 하는 메세지가 조금 헷갈림. (1) 라이브러리를 통해 외부 시스템과 통합시 주의하라는 것인지 (2) 라이브리러도 우리 애플리케이션과 통합 지점이기 때문에 주의하라는 것인지
- 해당 장의 문맥상 전자에 가까운 것 같아 보임.

#### 통합 지점 문제에 맞서기
- 모든 통합 지점은 어떤식으로든 고장남. 따라서 다양한 종류의 고장에 대비해야 함. 테스트 하니스를 통해 다양한 종류의 시스템과 네트워크 고장을 시뮬레이션.
- 통합지점 고장을 디버깅하기 위해 추상화된 계층 아래를 들여다 봐야 함. 앞선 사례에서 소켓,  TCP 모두 추상화 된 계층임.
- 우리의 코드가 충분히 방어적이지 않으면 원격 시스템에서 발생한 고장이 우리의 시스템에 연속적인 고장의 형태로 나타남.



## 5장. 안정성 패턴
여덟가지의 안정성 패턴을 소개하지만 적용 된 패턴의 수가 품질의 척도가 되진 않음을 이야기 함. 독자가 복구지향적인 마음을 키우길 바란다는데 무슨말인지? 어쨌든, 예상되는 고장에 맞게 패턴을 현명하게 적용해야 함.


### 제한시간
- 응답이 오지 않을 거라고 생각될 때 기다리는 것을 멈추게 하는 간단한 메커니즘.
- 잘 배치된 제한시간은 오류를 차단함. 그래서 다른 시스템 또는 다른 장치의 문제가 우리의 문제가 될 필요가 없음.
- 제한시간은 흔히 재시도와 함께 쓰이지만 빠르게 재시도하는 것은 다시 실패할 가능성이 매우 높음. ([지수 백오프 알고리즘](https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/implement-resilient-applications/explore-custom-http-call-retries-exponential-backoff) 등이 주로 쓰임)
- 다음 문장이 굉장히 인상 깊음. “어떤 경우이든지, 그냥 답을 갖고 돌아오라. 여러분이 작업을 재시도하면서 나를 기다리게 만든다면 여러분이 작업을 끝내기 전에 나는 여러분의 사이트를 떠날지도 모른다.”
- 또한, 당장 실시간으로 처리 되지 않아도 되는 작업들 예컨대, 메일, SMS 전송 등은 작업 큐에 올려 놓고 나중에 느리게 재시도 하는 것이 시스템을 훨씬 강건하게 만듬.

### 차단기
- 차단기는 작업을 다시 실행하기보다는 막기 위해 존재.
- 시스템이 스트레스를 받을 때 차단기가 동작하면 결과적으로 기능이 축소 되는데 이 때 어떤 방식, 어느 정도로 축소할 지 결정할 때는 시스템 이해 당사자(stackholder)를 포함하는게 필수적임.
- 차단기 상태 변화는 필히 노출시키고 추적하고 보고할 수 있어야 함. (로그, 모니터링 등)
- 또한, 운영팀은 수동으로 차단기의 상태를 변환시킬 수 있는 방법이 준비되어야 함.
- 차단기 패턴은 주로 제한시간 패턴과 함께 사용되는데, 제한시간은 통합 지점에 문제가 있음을 지적해주고 차단기는 통합 지점에 문제가 있을 때 호출하지 안헥 함.

### 칸막이
- 예컨대, 한 시스템 내에서 1:1문의, 공지사항을 서비스하고 있을 때, 1:1문의가 망가져도 공지사항은 동작해야 한다면 독립 된 서버로 구현할 수 있음.
- 시스템을 나눔으로써 시스템의 한 부분에서의 고장이 모든 것을 파괴하는 것을 막을 수 있음. 물리적 이중화가 칸막이의 가장 일반적 형태.
- 다만, 시스템이 위기에 빠지지 않았을 때 서버를 물리적으로 분할하는 것은 비용이 올라감.
- 적절한 세분하를 선택해야 함. 애플리케이션에서 스레드 풀을, 서버에서 CPU를, 클러스터에서 서버를 분할하는 등의 선택지가 있음.

### 정상상태
- 시스템은 가능한 오래 사람의 손이 닿지 않는게 제일. 계속 실행 되기 위해 사람의 개입이 많아지게 되면 의도하지 않은 에러가 생길 기회가 됨.
- 이 장에서 설명한 것은 시스템이 오랜 시간 동작하면서 계속 쌓이는 일종의 침천물의 몇 가지 종류와 이 침천물을 사람이 개입하지 않고 처리할 수 있는 방법을 소개함.
- 여기서 예로 든 침천물은 데이터, 로그, 캐시.

### 빠른 고장
- 느린 실패한 응답 > 느린 응답 > 무응답 순으로 나쁘다고 이야기 함.
- 느린 실패한 응답은 시스템의 리소스도 낭비함.
- 예컨대, 어떤 요청이 왔을 때 필요한 데이터베이스 연결, 외부 통합 지점 등 필요한 연결을 빨리 확인하고 차단기의 상태를 확인. 하나라도 문제가 있다면 중간 작업까지 가서 실패하는 대신 즉시 실패 처리를 함.
- 단, 빨리 실패할 때는 리소스 실패와 같은 시스템 실패를 매개변수 위반과 같이 애플리케이션 실패와는 다르게 취급해야 함. 같은 에러로 처리하면 차단기의 상태가 변경 되어버릴 수 있음.

### 핸드셰이킹
- 저수준의 프로토콜에서 어디든 존재하나, 애플리케이션 수준에서는 거의 존재하지 않음.
- 앞선 ‘빠른고장’은 일단 서버에 요청을 보낸 다음 실패하는 것이라면, 핸드셰이킹은 실제 요청을 보내기 전 클라이언트에서 서버의 ‘상태 확인’을 사용. 단, 서버가 처리해야 하는 연결과 요청은 두 배가 됨.
- 차단기는 핸드셰이킹을 할 수 없는 서비스에서 사용 가능한 임시방편이라고 이야기 함.

### 테스트 하니스
- 분산 시스템은 개발이나 QA 환경에서는 거의 발생시키기 힘든 고장 유형을 가짐.
- 원격 시스템을 믿을 수 없을 때, 로컬 시스템의 작동 방식을 테스트 하는 것은 필수적이고 이렇게 하기 위해 원격 시스템을 본 뜬 테스트 하니스를 만들 수 있음.
- 좋은 테스트 하니스는 상식을 벗어나야 함. 실제 세상의 시스템처럼 지저분하고 심술궃어야 함. 
- 저자는 예로 든 트릭 중 하나는 테스트 하니스가 포트마다 다르게 응답함. 포트 10200 에서는 연결만 수락하고 응답하지 않고, 10201 에서는 올바르지 않은 응답을, 10202 에서는 연결되자마자 끊어 버리는 등.
-   [chaos-monkey-spring-boot](https://github.com/codecentric/chaos-monkey-spring-boot)  같은 도구가 좋은 대안이 될 것 같음.

### 분리하는 미들웨어
- 여기서 이야기 하는 미들웨어는 메세지 브로커에 초점이 맞춰져 있는 듯 함.
- 모든 동기화 호출/응답은 호출하는 시스템이 하던 일을 멈추고 대기하게 하고 연속적인 고장을 촉진하는 악랄한 증폭기임.
- 메세지 지향 미들웨어는 시간과 공간에서 종단점을 분리함. 요청 시스템이 응답을 기다리며 가만히 있지 않으므로 연속적인 고장을 일으키지 않음. 개별 서버, 계층, 애플리케이션을 더 확실히 분리할수록 통합 지점, 연속적인 고장, 느린 응답, 블록된 스레드 등의 문제 발생이 더 적어짐.
- 하지만 비동기 프로세스를 설계하는 어려움, 미들웨어 도입으로 인한 시스템 아키텍처 자체의 변화, 미들웨어 제품 비용 등 트레이드 오프가 있음.
- 저자는 미들웨어로 분리하기는 일찍 이뤄져야 하는, 거의 돌이키기 어려운 결정 중 하나라고 설명함.
