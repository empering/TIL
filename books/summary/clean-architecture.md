# Clean Architecture

>  로버트 C. 마틴 저 | 송준이 역 | 인사이트출판 | 2019


![book-cover](https://user-images.githubusercontent.com/13076271/90978156-79333980-e586-11ea-8aa7-9dfdd4d755c7.jpg)

[책 구매하기](https://coupa.ng/bIGJRr)

>  위 링크를 통해 제품 구매가 이루어진 경우 쿠팡 파트너스 활동 일환으로 인해 일정 수수료가 블로거에게 제공됨.



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***

# 1부 소개

## 1장 설계와 아키텍처란

- 좋은 소프트웨어 설계의 목표: 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화

## 2장 두가지 가치에 대한 이야기

### 행위와 구조

- 첫째로 소프트웨어는 요구사항을 만족해야 함.
- 둘째로 소프트웨어라는 이름에 맞게 부드러워야 함. 다시 말해 변경하기 쉬워야 함.

### 더 높은 가치는

- 아이젠하워의 매트릭스에 따르면
  1. 긴급하고 중요한
  2. 긴급하지는 않지만 중요한
  3. 긴급하지만 중요하지 않은
  4. 긴급하지도 중요하지도 않은
- 소프트웨어의 두번째가치는 두번째에, 첫번째가치는 첫번째 또는 세번째에 속함.
- 하지만 현실에서 자주 저지르는 실수는 매트릭스에서 세번째에 속하는 첫번째 가치를 첫번째로 격상시켜 버림.
- 마케팅팀, 영업팀, 운영팀 모두 자신의 팀에서 가장 중요하다고 믿는 가치를 위해 투쟁 함.
- 소프트웨어 개발팀 역시 이를 위해 투쟁해야 함. 즉 때로는 두번째 가치를 위해 강하게 투쟁해야 한다고 말함.
  - 하지만 현실적으로 가파르게 비즈니스가 성장하는 곳에서 이런 투쟁은 쉽지 않음. 당장은 급하게 개발하더라도 추후에 개선하는 방법 등도 있음. 하지만 이 추후는 영영 오지 않는 경우도 있음을 주의.

# 3부 설계 원칙

### SRP

- 단 하나의 일만 해야 한다는 해석은 함수 수준에 적합. SOLID 에는 적합하지 않음.
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 함을 이야기.

### OCP

- 예제는 웹으로 출력되던 웹 페이지를 프린터로 출력되도록 요구사항이 변경.
- 이 때, 기존의 동작하던 코드의 변경량이 0 이라면 이상적인 훌륭한 아키텍처.
- 이러한 목적을 달성하기 위해 책임을 잘 나눠 클래스를 분리하고 저수준의 변경의 고수준을 보호할 수 있는 계층 구조를 만들어야 함.
- OCP 는 행위는 확장할 수 있어야 하지만, 산출물 (아마 코드?) 을 변경해서는 안된다는 규칙.

### LSP

- 유명한 정사각형/직사각형 상속 예제.
- LSP 를 위반하면 다형성을 활용하기가 어려움. 책의 앞쪽(50P)에서도 설명했지만 다형성은 플러그인 아키텍처를 가능하게 하는 중요한 메커니즘.
- LSP는 상속에 한정되는 것이 아니라 아키텍처 예컨대 REST 수준까지 확장해서 생각할 수 있음.
- 즉, 의존자는 추상화 되어 드러나있는 인터페이스에 의존하고 그 세부 구현은 변경 되더라도 행위 자체가 변경되어서는 안됨. 여기서 행위 역시 구체적인 행위를 뜻하는 것이 아닌 한단계 더 추상화 된 수준의..

### ISP

- 불 필요한 의존을 가지게 되면 예상치 못한 문제에 빠질 수 있음.
- 이 부분은 추후 13장 컴포넌트 응집도에서 좀 더 자세히 다룬다고 함.

### DIP

- DIP 에서 말하는 유연성이 극대화 된 시스템은 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템.
- 하지만 자바를 예로 들면 String 과 같은 구체 클래스에 의존하는 것은 불가피함.
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적 요소.
- DIP 는 컴포넌트를 구체적인 것과 추상적인 것, 이렇게 경계를 나누고 소스 코드 의존성은 모두 추상적인 쪽으로 향하도록 함.


# 5부 아키텍처
## 28장 테스트 경계
### 시스템 컴포넌트로서의 테스트
- 아키텍처의 가장 바깥쪽 원. 의존성은 항상 테스트 대상이 되는 코드를 향함. 반면, 시스템 내부의 어떤 것도 테스트에는 의존하지 않음.
- 독립적으로 배포. 또는 상용 시스템에는 아예 배포하지 않아도 됨.
- 시스템 컴포넌트 중 가장 고립됨.

### 테스트를 고려한 설계
- 대부분 테스트는 시스템의 설계 범위 밖에 있다고 여김.
- 문제는 테스트는 세부적이고 구체적인 것으로, 시스템으로 의존성을 향하고 있음.
- 시스템과 강하게 결합 된 테스트라면 시스템의 변경이 테스트의 변경을 유발함.
- 예컨대 GUI 를 테스트 하는 코드를 작성했다고 했을 때, 화면의 구조가 조금만 변경 되어도 엄청난 수의 테스트가 망가짐. 깨지기 쉬운 테스트는 시스템을 뻣뻣(rigid) 하게 만듬.
- 따라서 테스트를 고려해서 설계 해야 함. GUI 를 사용하지 않고 업무 규칙을 테스트 할 수 있게 만들어야 함. 즉, 변동성이 있는 것에 의존하지 말아야 함.

### 테스트 API
![구조적으로 결합하는 상용코드와 테스트코드](https://user-images.githubusercontent.com/13076271/66562969-b7568300-eb97-11e9-9bb6-7271e8e9c982.png)
- 구조적 결합은 테스트 결합 중 가장 강하고 은밀함. 모든 상용 클래스에 테스트 클래스가 각각, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트는 애플리케이션 구조에 강하게 결합 됨.
- 애플리케이션의 구조를 테스트로부터 숨기기 위해 테스트 API 를 사용.
- 이 API 를 관통하여 시스템의 핵심 업무 규칙들을 테스트 할 수 있음.
- 내가 이해한 바로는 test-api 라는 새로운 레이어 생기고, 이 레어어는 시스템과 테스트 사이에 존재.
- 이로 인해 시스템 변해도 테스트에 영향을 주지 않고 반대도 마찬가지. 시간이 지날수록 테스트는 더 구체적이고 더 특화된 형태로 시스템은 더 추상적이고 범용적인 형태로 따로 진화할 수 있음.

![테스트API](https://user-images.githubusercontent.com/13076271/66562981-ba517380-eb97-11e9-9dfc-a09df356f807.png)

이제까지 봤던 테스트 관련 글과는 전혀 다른 관점의 이야기라 내가 제대로 이해한게 맞는지 조금 의문. 이 챕터에 관한 다른 의견이 궁금해 찾아 봤으나 찾지 못함.
이제까지는 앞서 설명한 테스트 API 라는걸 본 적 없는데 이를 실제로 적용하기 위해서는 다음과 같은 고민들이 필요할 것 같음.

- 저자는 애초에 테스트를 시스템 컴포넌트의 하나로 다룸. 이 말에 팀원들이 모두 동의한다면 테스트 API 와 테스트를 잘 가꾸기 위해 노력하고 고민하는 것이 시간 낭비라고 생각하지 않을 수 있음. 하지만 모두의 동의를 얻는 것이 쉽지 않아 보임.
- 업무 규칙은 굉장히 중요함. 그리고 이런 규칙의 테스트베드도 중요하다고 생각. 하지만 업무 규칙에 관한 코드가 응집도 있게 모여 있으면 해당 코드에 대해 국소적으로 테스트 하는 것도 가능. 물론 구조적 결합은 피할 수 없음.
