# 데이터 중심 애플리케이션 설계

> 마틴 클레프만 저 | 정재부 , 김영준 , 이도경 역 | 위키북스 | 2018.

​	

![book-cover](https://user-images.githubusercontent.com/13076271/88173485-9b6f2a00-cc5d-11ea-8284-72ffb0f33174.jpg)

[책 구매하기](https://coupa.ng/bGCnLK)

>  위 링크를 통해 제품 구매가 이루어진 경우 쿠팡 파트너스 활동 일환으로 인해 일정 수수료가 블로거에게 제공됨.



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***




# 7장 트랜잭션

냉혹한 현실 세계 데이터 시스템은 여러 문제가 생길 수 있음.

- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있음
- 애플리케이션은 언제라도 죽을 수 있음
- 네트워크는 언제라도 갑자기 끊길 수 있음
- 여러 클라이언트가 동시에 데이터베이스 쓰기를 해서 내용을 덮어쓸 수 있음
- 클라이언트가 부분적으로 갱신 된 비정상 데이터를 읽을 수 있음
- 클라이언트 사이 경쟁 조건은 예측 못한 버그를 유발할 수 있음



수십년간 이런 문제를 단순화 하기 위해 트랜잭션이라는 메키니즘이 채택 됨. 

- 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
-  데이터베이스에 접속하는 애플리케이션에 프로그래밍 모델을 단순화하려는 목적으로 만들어짐
- 안정성 보장 (Safety Guarantee)



## 애매모호한 트랜잭션 개념

트랜잭션이 제공하는 안정성 보장은 ACID. 하지만 실제로 어떤 것을 기대할 수 있는지 분명하지 않으며 거의 마케팅 용어가 되어 버렸다고 함.

> ACID 표준을 따르지 않는 BASE 도 있음. Basically Available, Soft state, Eventual consistency. ACID 보다 더 모호함.



### 원자성

- 다중 스레드 프로그래밍에서는 원자성은 한 스레드가 연산을 실행하면 다른 스레드는 절반만 완료된 연산을 관찰할 수 없음. 즉, 실행 전 or 실행 후만 있음.
- 반면 ACID 맥락에서 원자성은 동시성과 무관. 여러 스레드가 동시에 접근할 때 무슨 일이 생기는지는 격리성에서 다룸.
- 대신 클라이언트가 쓰기 작업 몇 개를 실행하다 일부만 처리 후 결함이 생기면 무슨 일이 생기는지를 설명함. 원자적인 트랜잭션에 결함이 생기면 트랜잭션내에서 실행 된 쓰기를 무시하거나 취소 해야 함.
- 따라서 저자는 ACID 에서 A 는 원자성(Atomicity)보다 어보트 능력(Abortability) 가 더 적합한 단어가 아니냐고 이야기 함.

### 일관성

- 일관성 역시 복제, 해싱, CAP, ACID 각각의 맥락에서 여러가지 의미로 쓰임.
- 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 불변식이 있다는 것.
- 하지만 일관성은 데이터베이스가 보장할 수 있는 것이 아님. 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랙잭션을 올바르게 정의하는 것도 애플리케이션이 책임짐.
- 외래키제약, 유일성제약 등 데이터베이스에서 할 수 있는 특정 종류의 불변식이 있긴 하지만 일반적으로 데이터베이스는 단지 데이터를 저장할 뿐임.

### 격리성

- 여러 클라이언트에서 동일한 데이터베이스 레코드에 접근하면 동시성 문제가 생김.
- ACID 맥락에서 격리성은 동시에 실행 되는 트랜잭션이 서로 격리 된다는 것을 의미. 고전적인 데이터베이스 교과서에서는 격리성을 직렬성이라는 용어로 공식화 함.
- 즉, 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작함. (동시에 실행되더라도 하나씩 차례로)
- 하지만 직렬성(Serializable) 격리는 성능 손해를 동반함.

### 지속성

- ACID 맥락에서 지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함, 데이터베이스의 문제가 생겨도 기록한 데이터는 손실되지 않는다는 보장임.
- 단일 노드 데이터베이스에서 지속성은 일반적으로 비휘발성 저장소에 기록됐다는 의미로, 복제 기능이 있는 데이터베이스에서는 성공적으로 다른 노드에 복사됐다는 것을 의미.
- 하지만 모든 비휘발성 저장소와 백업이 동시에 파괴된다면 데이터베이스가 할 수 있는건 아무것도 없음.
- 현실에서 절대적 보장을 제공하는 기법은 없음. 디스크에 쓰기, 복제하기, 백업 등을 포함해 위험을 줄이는 기법이 있을 뿐. 이들은 함께 쓸 수 있으며 그래야만 함.
- 항상 이론적인 ‘보장’은 약간 에누리해서 듣는게 현명하다고 함.





### 단일 객체 연산과 다중 객체 연산
ACID 에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번 쓰기를 하면 데이터베이스가 어떻게 해야 하는지 서술.
- 원자성: 쓰기를 이어 실행 중 오류가 발생하면 트랜잭션은 어보트 돼야 하고 쓰여진 내용들은 폐기되어야 함. 전부 반영 or 전부 반영되지 않음.
- 격리성: 동시에 실행되는 트랜잭션들은 서로 방해하지 말아야 함. 예컨대 한 트랜잭션이 여러번 쓴다면 다른 트랜잭션은 그 내용을 전부 보거나 아무것도 보지 못해야 함.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true
```

- 어떤 사용자의 읽지 않은 메일 개수를 보여줄때 위와 같은 질의를 할 수 있음.
- 데이터가 많아지면 이 질의가 너무 느려질 수 있기 때문에 메시지 개수를 별도로 저장하는 시도를 생각할 수 있음 (일종의 비정규화)

```sql
-- T1. 새로운 이메일 데이터 추가
INSERT INTO emails (id, body, unread_flag) VALUES (2, 'Hello', true);

-- T2. 이메일 조회
SELECT body, unread_flag FROM emails WHERE id = 2 LIMIT 50;

-- T2. 이메일 개수 조회
SELECT unread_count FROM mailboxes WHERE id = 2;

-- T1. 이메일 개수 갱신
UPDATE mailboxes SET unread_count = unread_count + 1 WHERE id = 2;
```

- 위 예시에서 T2 사용자는 이상 현상을 경험하게 됨. 새로운 메일은 있지만 메시지 개수는 증가되지 않음.
- 격리성은 T2 가 삽입 된 이메일과 갱신된 갯수를 모두 보거나 모두 보지 못해야 함.
- 이런 다중 객체 트랜잭션을 위해 관계형 데이터베이스는 `BEGIN TRANSACTION ... COMMIT` 을 제공함. 하지만 이런 방식은 클라이언트와 데이터베이스 사이의 TCP 연결에 의존적이고 연결이 끊긴다면 클라이언트는 트랜잭션이 커밋됐는지 아닌지 알 수가 없음.
- 비관계형 데이터베이스에서는 이런 식으로 연산을 묶을 방법조차 없는 경우가 많음.
- 한편 원자성은 T1 에서 이메일 개수 갱신에 실패하면 트랜잭션은 어보트 되고 삽입 된 이메일은 롤백되어야 함.

단일 객체 쓰기
- 원자성과 격리성은 단일 객체를 변경하는 경우도 적용
	- 첫 10KB 를 보낸 후 네트웍이 끊긴다면?
	- 데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중 전원이 나간다면?
	- 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽는다면?
- 보편적으로 단일 객체 쓰기의 원자성은 장애 복구 로그를 통해서, 격리성은 각 객체에 잠금을 사용해 구현할 수 있음.
- 이러한 기법은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실 (lost update) 를 방지하지만 일반적으로 쓰이는 트랜잭션의 의미와는 조금 다름.
- 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해 됨.

오류와 어보트 처리
- 트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있는 것.
- 하지만 모든 시스템이 이 철학을 따르진 않음. 예컨대 다이나모DB 와 같이 리더 없는 복제를 사용하는 데이터스토어는 가능한 모든 것을 시도하며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않음. 따라서 애플리케이션에서 오류 복구를 책임져야 함.
- 트랜잭션 중 오류는 필연적으로 발생하게 되지만 많은 개발자들이 오류 처리의 복잡한 내용은 신경 쓰지 않고 낙관적인 상황만 생각함. 
- 반면 어보트된 트랜잭션을 재시도 하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않음.


## 완화된 격리 수준

- 동시성으로 인한 문제는 매우 드물게 발생할 수 있으며 재현이 어렵고 추론하기도 어려움.
- 따라서 두 트랜잭션이 동시에 접근하지 않으면 문제는 발생하지 않음.
- 데이터베이스는 트랜잭션 격리(transaction isolation)를 제공함으로써 애플리케이션 개발자에게 동시성 문제를 감추려고 했음.
- 직렬성(serializable) 격리는 여러 트랜잭션이 직렬적으로 실행되는 것 즉, 동시성 없이 한번에 트랜잭션이 하나만 실행되는 것과 동일한 결과가 나오도록 보장한다는 것을 의미.
- 하지만 직렬성 격리는 성능 비용이 있어 완화된 격리 수준을 사용하는 시스템이 흔함.
    - MySQL 의 기본 격리 수준은 Repeatable Read.
    - Oracle 은 Read Committed 인 듯 함.

### 커밋 후 읽기 (Read committed)

이 수준은 두가지를 보장 함.

- 읽을 때 커밋된 데이터만 봄 (더티 읽기 없음)
- 쓸 때 커밋된 데이터만 덮어 씀 (더티 쓰기 없음)

더티 읽기 방지

- 트랜잭션이 여러 객체를 갱신할때 더티 읽기가 생기면 다른 트랜잭션은 일부는 갱신된, 일부는 갱신되지 않은 값을 볼 수 있음. 부분적 갱신 상태를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션이 잘못된 결정을 하는 원인이 될 수 있음.
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백되어야 하는데, 다른 트랜잭션에서 더티 읽기로 롤백될 데이터를 읽게 되면 상황이 복잡해짐.

더티 쓰기 방지

- 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어쓰면 데이터가 잘못 됨.
- 보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두번째 쓰기를 지연시키는 방법 사용.

커밋 후 읽기 구현

- 오라클, 포스트그레스, SQL 서비 2012 등 여러 데이터베이스에서 기본 설정
- 가장 흔한 방법은 데이터베이스 로우 수준 잠금을 사용해 더티 쓰기 방지.
- 더티 읽기 방지 역시 잠금을 사용하는 방법이 있으나 이는 읽기만 실행하는 트랜잭션들의 응답 시간에 해를 끼침. 따라서 데이터베이스는 모든 객체에 대해 과거 커밋 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션의 새로운 값을 모두 기억한 후, 해당 트랜잭션의 샐항 동안 그 객체를 읽는 다른 트랜잭션은 과거의 값을 읽음.

### 스냅숏 격리와 반복 읽기

커밋 후 읽기를 피상적으로 보면 트랜잭션이 해야 할 일을 모두 해주는 것 같음.
하지만 커밋 후 읽기에서도 동시성 버그가 일어날 경우가 있음.

```sql
-- 각 계좌에 잔고는 500원씩 있는 상황
-- T1. 1번계좌 조회
SELECT balance FROM accounts WHERE id = 1 -- 500원. 송금 처리 되기 전임

-- T2. 1번 계좌에 송금
UPDATE accounts SET balance = balannce + 100 WHERE id = 1

-- T2. 2번 계좌에서 출금
UPDATE account SET balance = balance - 100 WHERE id = 2

-- T1. 2번 계좌 조회
SELECT balance FROM accounts WHERE id = 2 -- 400원. 반면 출금은 이미 됨.
```

- T1 사용자가 본인 계좌 2 -> 1로 송금 트랜잭션이 진행되고 있는 동안 각 계좌를 조회한다면 한 계좌(id: 2)는 출금 후 상태, 한 계좌(id: 1)는 입금 전 상태를 보게 됨.
- 이런 현상을 비반복 읽기 (non-repeatable read) 라고 함. (또는 read skew)
- 스냅숏 격리는 이런 문제의 가장 흔한 해결책. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽음.

스냅숏 격리 구현

- 스냅숏 격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고, 반대도 마찬가지.
- 따라서 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 처리되고 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있음.
- 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수 도 있기 때문에 객체의 여러 버전을 함께 유지. 이 기법을 다중 버전 동시성 제어 (multi-version concurrency control, MVCC) 라고도 함.

혼란스러운 이름

- 오라클에서는 스냅숏 격리를 Serialize, 포스트그레스큐엘과 MySQL에서는 Repeatable Read 로 부름.
- 이렇게 이름이 혼란스러운 이유는 SQL 표준에 스냅숏 격리 개념이 없기 때문.
- 대신 스냅숏 격리와 비슷해 보이는 Repeatable Read 는 표준에 정의되어 있음.
- 하지만 표준 역시 모호하고 부정확하며 구현 독립적이지 않음.

### 갱신 손실 방지

- 커밋 후 읽기 부분에서 쓰기 충돌 중 더티 쓰기에 대해서만 이야기 함.
- 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌은 몇 가지가 더 있으며 가장 널리 알려진건 갱신 손실 (lost update).
- 해결책
    1. 원자적쓰기연산
        - `UPDATE counters SET value = value + 1 WHERE key = 'foo'`
        - 이런 연산이 가능하다면 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애줌. 하지만 ORM 을 사용한다면 이런 구현이 쉽지 않음.
    2. 명시적인잠금
        - `SELECT... FOR UPDATE`
        - 로우를 명시적으로 잠금으로써 갱신 손실을 막을 수 있음.
        - 올바르게 동작하게 하려면 애플리케이션 로직에서 필요한 잠금을 추가하는 것을 잘 챙겨야 함.
    3. 갱신 손실 자동 감지
        - 앞선 원자적연산과 잠금은 read-modifiy-write 가 순차적으로 강제했다면 이 방법은 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 스스로 재시도하도록 강제하는 방법. (즉, 비선점 잠금)
        - 이는 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것.
    4. Compare-and-set
        - 트랜잭션을 제공하지 않는 데이터베이스 중 원자적 CAS 를 제공하는 것도 있음.
        - 값을 마지막으로 읽은 후 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실 회피.
- 반면, 복제가 적용된 데이터베이스에서 갱신 손실을 막는 것은 차원이 다른 문제임. 잠금과 CAS 는 데이터 최신 복사본이 하나만 있다고 가정함. 따라서 사용 불가.

### 쓰기 스큐와 팬텀

![https://user-images.githubusercontent.com/13076271/88479367-a1c91300-cf89-11ea-895d-f526e02f4636.png](https://user-images.githubusercontent.com/13076271/88479367-a1c91300-cf89-11ea-895d-f526e02f4636.png)

한 시점에 최소 한 명의 의사는 호출 대기를 해야 함. 하지만 위 예에서는 두 트랜잭션이 서로 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아님.

- 충돌이 발생했다는 것은 덜 명백해 보이지만 분명한 경쟁 조건임.
- 이런 현상을 쓰기 스큐 (write skew) 라고 함.
- 그리고 이를 해결하기 위한 방법은 갱신 손실을 막는 것보다 더 제한적임.
- 데이터베이스의 제약 조건을 활용하거나, SELECT 시 관련 로우를 모두 잠그는 방법이 있음.

쓰기 스큐를 유발하는 팬텀

- 쓰기 스큐가 발생하는 예는 모두 비슷한 패턴을 띔.
    1. SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색
    2. 첫번째 질의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정
    3. 애플리케이션이 계속 처리하기로 결정했다면 쓰고 커밋. 이 쓰기 효과로 (2)를 결정한 전제 조건이 바뀜.
- 이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 함.

충돌 구체화

- 인위적으로 잠금 객체를 추가할 수 있음.
- 위 예제로 하자면 의사:호출대기시간 맵핑 테이블을 두고 트랜잭션을 시작할 때 해당 로우를 잠금.이 테이블은 단지 잠금의 모음.
- 이런 방법을 충돌 구체화라고 함.
- 유감스럽게 이처럼 충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉬움. 또한 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나옴.
- 이런 까닭으로 충돌 구체화는 다른 대안이 불가능할 때 최후의 수단으로 고려해야 함.
- 대부분의 경우 직렬성 격리 수준이 훨씬 선호됨.

## 직렬성

- 직렬성 격리는 보통 가장 강력한 격리 수준으로 여겨짐.
- 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한번에 하나씩 직렬로 실행될 때와 같도록 보장.
- 이를 구현하는 방법은 크게 세 가지 기법이 있음.

### 실제적인 직렬 실행

- 동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것.
- 뻔한 생각처럼 보이지만 데이터베이스 설계자들은 최근(2007년경)이 돼서 단일 스레드 루프에서 트랜잭션을 실행하는게 가능하다고 결론 내림.
- 과거 30년 동안 높은 성능을 위해 다중 스레드 동시성이 필수로 여겨지다 생각이 바뀐 이유는 (1)램 가격이 저렴해짐 (2)OLTP 트랜잭션은 보통 짧고 실행하는 읽기와 쓰기 개수가 적다는 것을 깨달음.

### 2단계 잠금(2PL)

- 쓰기 실행 트랜잭션이 없는 객체는 여러 트랜잭션에서 읽도록 하되, 누군가 쓰려고 한다면 독점적인 접근.
- 만약 트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전 A가 커밋되거나 어보트될때까지 기다려야 함.
- 2PL은 MySQL 에서 직렬성 격리 수준을 구현하는데 쓰이며 잠금을 통해 구현. shared mode 와 exclusive mode.
- 2PL의 가장 큰 약점은 성능임.

### 직렬성 스냅숏 격리(SSI)

- 2PL은 이른바 선점 동시성 제어. 반대로 SSI는 비선점 동시성 제어 기법임.
- 트랜잭션은 어떤 전제를 기반으로 동작. 앞선 의사의 호출대기 예제에서는 현재 두명의 의사가 호출 대기 중이다 라는 전제. 트랜잭션 커밋 시점에 이 전제는 참이 아닐 수 있음.
- 전제가 바뀌었는지 확인하기 위해서는 (1)오래된 MVCC 객체 버전을 읽었는지 감지 (2)과거의 읽기에 영향을 미치는 쓰기 감지가 필요.

