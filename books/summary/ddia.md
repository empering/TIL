# 데이터 중심 애플리케이션 설계

> 마틴 클레프만 저 | 정재부 , 김영준 , 이도경 역 | 위키북스 | 2018.

​	

![book-cover](https://user-images.githubusercontent.com/13076271/88173485-9b6f2a00-cc5d-11ea-8284-72ffb0f33174.jpg)

[책 구매하기](https://coupa.ng/bGCnLK)

>  위 링크를 통해 제품 구매가 이루어진 경우 쿠팡 파트너스 활동 일환으로 인해 일정 수수료가 블로거에게 제공됨.



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***




## 7장 트랜잭션

냉혹한 현실 세계 데이터 시스템은 여러 문제가 생길 수 있음.

- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있음
- 애플리케이션은 언제라도 죽을 수 있음
- 네트워크는 언제라도 갑자기 끊길 수 있음
- 여러 클라이언트가 동시에 데이터베이스 쓰기를 해서 내용을 덮어쓸 수 있음
- 클라이언트가 부분적으로 갱신 된 비정상 데이터를 읽을 수 있음
- 클라이언트 사이 경쟁 조건은 예측 못한 버그를 유발할 수 있음



수십년간 이런 문제를 단순화 하기 위해 트랜잭션이라는 메키니즘이 채택 됨. 

- 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
-  데이터베이스에 접속하는 애플리케이션에 프로그래밍 모델을 단순화하려는 목적으로 만들어짐
- 안정성 보장 (Safety Guarantee)



### 애매모호한 트랜잭션 개념

트랜잭션이 제공하는 안정성 보장은 ACID. 하지만 실제로 어떤 것을 기대할 수 있는지 분명하지 않으며 거의 마케팅 용어가 되어 버렸다고 함.

> ACID 표준을 따르지 않는 BASE 도 있음. Basically Available, Soft state, Eventual consistency. ACID 보다 더 모호함.



#### 원자성

- 다중 스레드 프로그래밍에서는 원자성은 한 스레드가 연산을 실행하면 다른 스레드는 절반만 완료된 연산을 관찰할 수 없음. 즉, 실행 전 or 실행 후만 있음.
- 반면 ACID 맥락에서 원자성은 동시성과 무관. 여러 스레드가 동시에 접근할 때 무슨 일이 생기는지는 격리성에서 다룸.
- 대신 클라이언트가 쓰기 작업 몇 개를 실행하다 일부만 처리 후 결함이 생기면 무슨 일이 생기는지를 설명함. 원자적인 트랜잭션에 결함이 생기면 트랜잭션내에서 실행 된 쓰기를 무시하거나 취소 해야 함.
- 따라서 저자는 ACID 에서 A 는 원자성(Atomicity)보다 어보트 능력(Abortability) 가 더 적합한 단어가 아니냐고 이야기 함.

#### 일관성

- 일관성 역시 복제, 해싱, CAP, ACID 각각의 맥락에서 여러가지 의미로 쓰임.
- 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 불변식이 있다는 것.
- 하지만 일관성은 데이터베이스가 보장할 수 있는 것이 아님. 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랙잭션을 올바르게 정의하는 것도 애플리케이션이 책임짐.
- 외래키제약, 유일성제약 등 데이터베이스에서 할 수 있는 특정 종류의 불변식이 있긴 하지만 일반적으로 데이터베이스는 단지 데이터를 저장할 뿐임.

#### 격리성

- 여러 클라이언트에서 동일한 데이터베이스 레코드에 접근하면 동시성 문제가 생김.
- ACID 맥락에서 격리성은 동시에 실행 되는 트랜잭션이 서로 격리 된다는 것을 의미. 고전적인 데이터베이스 교과서에서는 격리성을 직렬성이라는 용어로 공식화 함.
- 즉, 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작함. (동시에 실행되더라도 하나씩 차례로)
- 하지만 직렬성(Serializable) 격리는 성능 손해를 동반함.

#### 지속성

- ACID 맥락에서 지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함, 데이터베이스의 문제가 생겨도 기록한 데이터는 손실되지 않는다는 보장임.
- 단일 노드 데이터베이스에서 지속성은 일반적으로 비휘발성 저장소에 기록됐다는 의미로, 복제 기능이 있는 데이터베이스에서는 성공적으로 다른 노드에 복사됐다는 것을 의미.
- 하지만 모든 비휘발성 저장소와 백업이 동시에 파괴된다면 데이터베이스가 할 수 있는건 아무것도 없음.
- 현실에서 절대적 보장을 제공하는 기법은 없음. 디스크에 쓰기, 복제하기, 백업 등을 포함해 위험을 줄이는 기법이 있을 뿐. 이들은 함께 쓸 수 있으며 그래야만 함.
- 항상 이론적인 ‘보장’은 약간 에누리해서 듣는게 현명하다고 함.





### 단일 객체 연산과 다중 객체 연산
ACID 에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번 쓰기를 하면 데이터베이스가 어떻게 해야 하는지 서술.
- 원자성: 쓰기를 이어 실행 중 오류가 발생하면 트랜잭션은 어보트 돼야 하고 쓰여진 내용들은 폐기되어야 함. 전부 반영 or 전부 반영되지 않음.
- 격리성: 동시에 실행되는 트랜잭션들은 서로 방해하지 말아야 함. 예컨대 한 트랜잭션이 여러번 쓴다면 다른 트랜잭션은 그 내용을 전부 보거나 아무것도 보지 못해야 함.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true
```

- 어떤 사용자의 읽지 않은 메일 개수를 보여줄때 위와 같은 질의를 할 수 있음.
- 데이터가 많아지면 이 질의가 너무 느려질 수 있기 때문에 메시지 개수를 별도로 저장하는 시도를 생각할 수 있음 (일종의 비정규화)

```sql
-- T1. 새로운 이메일 데이터 추가
INSERT INTO emails (id, body, unread_flag) VALUES (2, 'Hello', true);

-- T2. 이메일 조회
SELECT body, unread_flag FROM emails WHERE id = 2 LIMIT 50;

-- T2. 이메일 개수 조회
SELECT unread_count FROM mailboxes WHERE id = 2;

-- T1. 이메일 개수 갱신
UPDATE mailboxes SET unread_count = unread_count + 1 WHERE id = 2;
```

- 위 예시에서 T2 사용자는 이상 현상을 경험하게 됨. 새로운 메일은 있지만 메시지 개수는 증가되지 않음.
- 격리성은 T2 가 삽입 된 이메일과 갱신된 갯수를 모두 보거나 모두 보지 못해야 함.
- 이런 다중 객체 트랜잭션을 위해 관계형 데이터베이스는 `BEGIN TRANSACTION ... COMMIT` 을 제공함. 하지만 이런 방식은 클라이언트와 데이터베이스 사이의 TCP 연결에 의존적이고 연결이 끊긴다면 클라이언트는 트랜잭션이 커밋됐는지 아닌지 알 수가 없음.
- 비관계형 데이터베이스에서는 이런 식으로 연산을 묶을 방법조차 없는 경우가 많음.
- 한편 원자성은 T1 에서 이메일 개수 갱신에 실패하면 트랜잭션은 어보트 되고 삽입 된 이메일은 롤백되어야 함.

#### 단일 객체 쓰기
- 원자성과 격리성은 단일 객체를 변경하는 경우도 적용
	- 첫 10KB 를 보낸 후 네트웍이 끊긴다면?
	- 데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중 전원이 나간다면?
	- 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽는다면?
- 보편적으로 단일 객체 쓰기의 원자성은 장애 복구 로그를 통해서, 격리성은 각 객체에 잠금을 사용해 구현할 수 있음.
- 이러한 기법은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실 (lost update) 를 방지하지만 일반적으로 쓰이는 트랜잭션의 의미와는 조금 다름.
- 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해 됨.

#### 오류와 어보트 처리
- 트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있는 것.
- 하지만 모든 시스템이 이 철학을 따르진 않음. 예컨대 다이나모DB 와 같이 리더 없는 복제를 사용하는 데이터스토어는 가능한 모든 것을 시도하며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않음. 따라서 애플리케이션에서 오류 복구를 책임져야 함.
- 트랜잭션 중 오류는 필연적으로 발생하게 되지만 많은 개발자들이 오류 처리의 복잡한 내용은 신경 쓰지 않고 낙관적인 상황만 생각함. 
- 반면 어보트된 트랜잭션을 재시도 하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않음.


