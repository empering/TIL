# 오브젝트
> 조영호 저, 위키북스, 2019 [링크](http://www.yes24.com/Product/Goods/74219491?scode=032&OzSrank=1)  

본 내용은 책 일부의 요약과 개인의 생각이 뒤섞여 있으므로 꼭 직접 책을 참고하시길 권함.

# 1장. 객체, 설계
## 의존성과 캡슐화
- 의존성은 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실을 내포. 객체간 의존성이 과할 때 결합도가 높다고 말함.
- 어떤 객체가 변경 될 때 그 객체에 의존하는 객체가 세부 사항을 너무 많이 알고 있으면 함께 변경될 수 밖에 없음. 이런 변경은 버그를 부르고 버그에 대한 두려움은 코드의 변경을 어렵게 함.
- 캡슐화를 통해 객체 내부의 세부 사항을 감춤으로써  객체 사이의 결합도를 낮출 수 있음.  즉, 캡슐화는 객체의 변경을 쉽게 만들어줌.

## 객체지향 설계와 트레이드 오프
- 책 예제의 코드를 개선하는 과정에서 변경 전에 없던 새로운 의존 관계가 생김. 이 예제를 통해 두가지 메세지를 전달. 첫째, 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있음. 둘째, 동일한 기능을 한 가지 이상 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물임. 은 총알은 없음.
- 객체지향 패러다임 역시 마찬가지. 객체지향이 적합하지 않은 상황에서는 언제라도 다른 패러다음을 적용할 수 있는 시야를 길러야 함.
- 좋은 설계란 오늘의 요구 사항을 온전히 수행하며 내일의 변경을 매끄럽게 수용할 수 있는 것.
- 좋은 객체지향 설계란 객체 사이의 의존성을 적절하게 관리하는 것.

## 의인화
```java
public class Theater {
    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffcie().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```
- 위 코드는 `Theater` 가 모든 책임을 지고 너무 많은 객체에 의존하고 있음. 매표소에서 티켓을 가져와서 관람객의 가방을 열어 초대장이 있는지 확인하고, 있으면 티켓을 넣어주고 없으면 돈을 꺼내고..
- 예제에 등장하는 영화관, 가방, 매표소 등은 현실 세계에서는 모두 수동적인 존재. 하지만 객체지향 세계에서는 능동적이고 자율적인 존재로 의인화 되야 함.
- 각 객체가 적절한 책임을 할당함으로써 응집도를 높이고 객체간의 결합도를 낮출 수 있음.
- 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것.

# 2장. 객체지향 프로그래밍
## 컨텍스트 식별과 유비쿼터스 랭귀지
- 해당 장은 영화 예매 프로그램을 예제로 시작하기 전 사용자가 실제로 예매하는건 ‘영화’가 아닌 ‘상영’ 이라는 것을 식별해냄. 할인 조건에는 ‘순서 조건’과 ‘기간 조건’ 두 종류로 구분 정의.
- 컨텍스트를 식별하여 분리하고 공통의 언어를 정의함으로써 의사소통이 수월 해지고 유스케이스가 명확해짐. 새삼 컨텍스트와 언어가 얼마나 중요한 것인지 다시 생각함.

## 클래스 의존성과 객체 의존성의 트레이드 오프
- 1장에 이어 2장에서도 다시 트레이드 오프에 관한 이야기가 나옴.
- 코드 의존성과 실행 시점 의존성이 다를수록 코드의 이해는 어려워짐. 반면, 코드는 더 유연해짐.
- 모든 코드에는 합당한 이유가 있어야 하고 트레이드 오프를 고민해야 함.
- 이전에 추상 클래스와 인터페이스 등을 적용해서 변경 가능성에 비해 과도하게 추상화 된 코드를 작성한 경험이 있음.  어느정도 미래를 대비하여 어느정도 유연해야 하냐는 항상 어려운 고민. [클린소프트웨어(로버트C마틴)](https://github.com/iamkyu/TIL/blob/master/books/summary/clean-software.md#9-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-open-closed-principle)에서는 미래는 완벽하게 예측할 수 없으니 일단 올가미를 놓으라고 함.

## 인터페이스와 구현의 분리
- 내부 구현은 은닉하고 외부에서는 인터페이스만 알고 있음으로써 사용하는 쪽에서 복잡한 내부 사정을 다 알 필요가 없음. 따라서 [DDD (에릭에반스)](https://github.com/iamkyu/TIL/blob/master/books/summary/ddd.md#%EC%9D%98%EB%8F%84%EB%A5%BC-%EB%93%9C%EB%9F%AC%EB%82%B4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4) 에서 인터페이스는 의도를 분명히 드러내야 한다고 이야기 함.
- 인터페이스는 복잡함을 다루는 한가지 방법이라 생각. 사용하는 쪽에서는 내부 구현은 무시한 채 인터페이스만 알고 있으면 됨. 단, 인터페이스를 통해 기대하는대로 동작한다고 가정. 그리고 기대 하지 않은 사이드 이펙트를 발생 시키면 안됨.

## 상속
- 상속의 가치는 상위 클래스의 모든 인터페이스를 하위 클래스가 물려 받을 수 있기 때문. 메서드나 인스턴스 변수를 재사용하는 것이 주 목적은 아님.
- 인터페이스를 물려 받는다는건 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있다는 것. 이는 같은 타입으로 간주할 수 있다는 것을 의미함.
- 구현을 재사용할 목적으로 구현상속(서브클래싱) 을 사용하면 상위 클래스 구현이 하위 클래스에게 노출되기 때문에 캡슐화가 약화 됨.
- 상속은 구현상속이 아닌 인터페이스 상속(서브타이핑) 을 사용할 것을 권함.

## 메시지와 메서드
```java
public interface DiscountPolicy {
	Money caculateDiscountAmount(Screening screening);
}
```
- 객체와 다른 객체간의 상호 방법 작용은 메세지를 통함. 객체가 수신 된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 정리.
- 자신과 협력하는 객체가 어떤 클래스의 인스턴스인지는 중요하지 않음. 자신이 전송하는 메세지를 수신할 수 있다는 사실이 중요.
- `DiscountPolicy` 와 협력하는 객체들은 `DiscountPolicy`에게 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 클래스가 무엇이냐에 따라 달라짐.
- 동일한 메시지를 수신할 때 타입에 따라 다르게 응답할 수 있는 능력을 다형성이라 함.

# 3장. 역할, 책임, 협력
> 어떤 객체도 섬이 아니다.

- 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력임을 강조.
- 협력이라는 문맥안에서 객체들은 책임을 가지고 각 책임의 집합을 역할이라고 할 수 있음.
- 협력, 어떤 객체가 필요한 이유는 어떤 협력에 참여하기 때문. 그리고 그 협력의 컨텍스트 안에서 객체의 행동이 정의 됨. 예컨대 영화 예매 시스템이라는 컨텍스트 안에서 `Movie` 는 영화 상영이 아닌 요금을 계산하는 행동을 가짐.
- 책임, 객체에게 책임을 할당하는데 필요한 메시지를 먼저 식별하고 이를 처리할 객체는 나중에 선택. ‘예매하라’ 라는 메시지를 먼저 식별하고 책임을 `Screening` 에게 부여. 이렇게 했을때 객체는 (1) 최소한의 인터페이스를 가짐 (2) 충분히 추상적인 인터페이스를 가질 수 있음.
- 역할, 특정한 협력 안에서 수행하는 책임의 집합. 이 역할이라는 슬롯에 같은 책임을 가지는 객체를 바꿔 끼울 수 있음. `DiscountPolicy` 라는 역할은 `AmountDiscountPolicy`, `PercentDiscountPolicy` 객체등으로 바꿔 끼울 수 있음. 역할은 특정한 객체의 종류를 캡슐화하기 때문에 동일한 역할을 수행하며 계약을 준수하는 대체 가능한 객체들은 다형적.
