# HTTP 완벽 가이드

> 원제: HTTP: THE DEFINITIVE GUIDE
>
> 데이빗 고울리 외 4명. 이용원 외 1명 역. 인사이트. 2014 [[상세정보]](https://book.naver.com/bookdb/book_detail.nhn?bid=8509980)



## 14장. 보안 HTTP

> [생활코딩 HTTPS와 SSL 인증서](https://opentutorials.org/course/228/4894) 을 함께 참고함.

- HTTPS 는 HTTP 를 안전하게 만드는 방식 중 하나이며 가장 인기 있는 것.
- HTTPS 는 TCP 위에 놓인 보안 계층 위의 HTTP 임.
- 이 보안 계층은 Secure Sockers Layer 혹은 그를 계승한 Transport Layer Security 을 이용해 구현.
  - 네스케이프에 의해 SSL이 발명된 후, 표준화 기구인 IETF의 관리로 변경되며 TLS 로 이름 변경. TLS 1.0 은 SSL 3.0 을 계승
- HTTPS 위의 모든 HTTP 요청, 응답 데이터는 네트워크로 보내지기 전 암호화 됨.



### 대칭키 암호법

- 인코딩, 디코딩에 같은 키를 사용
- 발송자와 수신자 모두 통신을 위해 비밀키를 똑같이 공유해야 함
- DES, Triple-DES, RC2, RC4 등
- 문제는 비밀키를 한 쌍의 호스트가 사전에 어떻게 공유할 것인가?



### 공개키 암호법

- 한 쌍의 호스트가 인코딩/디코딩 키를 사용하는 대신 두 개의 비대칭 키 사용
- 하나는 호스트의 메시지를 인코딩, 다른 하나는 호스트의 메시지를 디코딩하기 위한 것
- 인코딩키는 모두에게 공개, 하지만 디코딩 키는 호스트만이 알고 있음
- 가장 유명한 공개키 암호 체계는 [RSA](https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8) 알고리즘
- 비대칭 공개키 암호 방식은 훌륭하지만 알고리즘의 계산이 느린 경향이 있음
- 이를 극복하기 위해 대칭과 비대칭 방식을 섞은 방식이 많이 쓰임



### 디지털 서명

- 메시지에 붙어 있는 특별한 암호 [체크섬](https://ko.wikipedia.org/wiki/%EC%B2%B4%ED%81%AC%EC%84%AC)
- 서명은 메시지를 작성한 저자가 누군지 알려줌. 저자만이 개인 키를 가지고 있기 때문에 오직 본인만 이 체크섬을 계산 가능
- 서명은 메시지 위조를 방지함. 공격자가 송신 중인 메시지를 수정했다면 체크섬은 더 이상은 메시지와 맞지 않게 됨
- 대략적인 절차
  1. 노드 A는 가변 길이 메시지를 정제해 고정된 길이의 요약(digest)로 만듬
  2. 그 요약에 개인 키를 매개변수로 하는 '서명' 함수를 적용. 이를 메시지 끝에 덧붙임
  3. 노드 B 는 메시지를 받은 후, 공개키를 이용한 역함수를 적용해 서명을 검사 가능 (공개키로는 디코딩이 불가해야 하는데 여기서는 왜 가능? 생활코딩에 따르면 비공키를 이용해 암호화 된 정보는 공개키를 통해 복호화 가능한 듯)



### 디지털 인증서

- 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보가 담김
- 다음과 같은 정보의 집합. 대상의 이름 (사람, 서버, 조직 등), 유효기간, 인증서발급자, 발급자의 디지털 서명
- 추가로 보통 대상의 공개키와 공개키의 암호화 방법 등도 담김
- 사용자가 HTTP를 통해 웹 트랜잭션을 시작할 때, 
  - 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴
  - 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 알고 있을 것이고 이를 통해 인증서의 디지털 서명을 검증



### HTTPS의 세부사항

#### 핸드쉐이크

- C: 서버의 443포트로 연결

- C: 랜덤데이터, 클라이언트가 지원하는 암호화 방식, 세션아이디(첫 연결 이후) 전송 (client hello)
- S: 랜덤데이터, 서버가 선택한 암호화 방식, 세션아이디(첫 연결), 인증서를 보냄.  (server hello)
- C: 서버에서 받은 인증서를 CA 의 공캐키를 이용해 복호화. 서버의 랜덤데이터와 클라이언트의 랜덤데이터를 조합해 대칭키(pre master secret)를 생성. 이를 인증서에 담긴 공개키를 이용해 암호화.
- S: 클라이언트가 전송한 pms 를 비공캐키로 복호화 후 앞서 생성한 클라이언트, 서버의 랜덤 데이터 값을 암호화 함수를 이용하여 master secret 생성. 이를 이용한 세션키를 만듬. (TODO 이 부분 어렵다!)
- C, S: 핸드쉐이크 종료를 서로 알림



#### 세션

- 앞서 생성 된 session key 를 통해 주고 받는 데이터의 암호화
- 데이터 전송이 끝나며 SSL 통신이 끝났음을 서로 알리고 세션키는 폐기