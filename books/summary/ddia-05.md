# 데이터 중심 애플리케이션 설계

> 마틴 클레프만 저 | 정재부 , 김영준 , 이도경 역 | 위키북스 | 2018.


![book-cover](https://user-images.githubusercontent.com/13076271/88173485-9b6f2a00-cc5d-11ea-8284-72ffb0f33174.jpg)

[책 구매하기](https://coupa.ng/bGCnLK)

>  위 링크를 통해 제품 구매가 이루어진 경우 쿠팡 파트너스 활동 일환으로 인해 일정 수수료가 블로거에게 제공됨.



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***




# 5장. 복제

여기서 복제란 네트워크로 연결된 여러 장비에 동일한 데이터 복사본을 유지한다는 의미. 복제가 필요한 이유는 다음과 같음.

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연시간을 줄임
- 시스템 일부에 장애가 발생해도 지속 동작하도록 해 가용성을 높임
- 읽기 질의를 제공하는 장비 수를 확장해 처리량을 늘림

복제의 어려움은 복제 중인 데이터가 계속 변한다는 것. 노드 간 변경을 복제하기 위해 인기 있는 알고리즘은 단일리더, 다중리더, 리더없는 복제.

## 리더와 팔로워

데이터베이스 복사본을 저장하는 각 노드를 replica 라고 함. 모든 복제 서버에 모든 데이터를 복제 하기 위한 가장 일반적인 해결책은 리더 기반 복제. 쓰기는 리더를 통해서만 일어난 후 복제 로그 또는 변경 스트림을 팔로워에게 전송하여 리더와 동일한 순서로 쓰기 적용.

### 동기식 vs 비동기식 복제

동기식 복제

- 장점: 팔로워가 리더와 일관성 있게 최신 복사본을 가짐
- 단점: 팔로워 중 한 노드라도 장애가 난다면 전체 시스템이 멈춤

반동기식 복제

- 동기식 복제의 단점을 보완하기 위한 타협안
- 적어도 두 노드 (리더 하나, 팔로워 하나)에 최신 복사본이 있는 것을 보장 즉, 동기 복제하고 그 밖에 팔로워는 비동기식 복제

보통 리더 기반 복제는 완전히 비동기식으로 구성한다고 함.

- [MySQL 8.0 Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/replication.html) 도입부를 보면 비동기 복제
- [Amazon Aurora](https://aws.amazon.com/rds/aurora/faqs)의 High Availability and Replication 절을 보면 역시 비동기 복제

### 새로운 팔로워 설정

새로운 노드 즉, 팔로워가 투입 되었을 때 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할 것인가. 

- 특정 시점의 리더 스냅숏을 가져와서 새로운 팔로워 노드에 복사
- 새 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청
- 이를 위해서 스냅숏이 어디까지의 데이터를 가지고 있는지 일종의 위치 정보가 필요한데 MySQL 에서는 이를 binglog coordinate, Postgres 에서는 log seq number 라고 함.

### 노드 중단 처리

#### 팔로워 장애

- 팔로워가 재시작하거나 리더와 네트웍이 일시적으로 중단된다면 팔로워는 쉽게 복구할 수 있는 편
- 팔로워는 리더로부터 수신한 데이터 변경 로그를 가지고 있는데, 결함이 발생하기 전 마지막 처리한 트랜잭션을 알아낸 후 해당 시점 이후의 데이터 변경을 리더에 요청

#### 리더 장애

- 팔로워에 비해 까다로움.
- 팔로워 중 하나를 새로운 리더로 승격, 클라이언트는 새로운 리더로 쓰기를 전송하기 위한 설정, 팔로워들은 새로운 리더로부터 데이터 변경을 소비하기 시작해야 함. 이 과정을 failover 라고 함.

페일오버 과정은 잘못될 수 있는 것 투성이.

- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더의 실패하기 전 쓰기를 일부 수신하지 못했을 수 있음. 그리고 문제가 발생한 기존 리더가 복구되어 다시 클러스터에 추가된다면? 그 사이 새 리더가 충돌하는 쓰기를 수신했다면?
- 2018년 10월, [Github에서 발생한 장애](https://muchtrans.com/translations/github-oct-21-post-incident-analysis.ko.html)가 이에 해당. 모든 상황이 정확히 이해는 안되지만 유효하지 않은 노드가 리더로 선출된 것.
- 가장 일반적인 해결은 이전 리더의 복제되지 않은 쓰기를 폐기하는 것. 하지만 이는 내구성에 대한 기대를 저버리고 만약 외부의 다른 저장소 예컨대 레디스와 같은 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 위험할 수 있음. 데이터베이스와 레디스가 동일한 키를 사용하다가 새로운 리더 선출로 인해 데이터베이스와 레디스의 키가 불일치 된다던가.
- 특정 결함 시도에서 두 노드가 모두 자신이 리더라고 믿을 수 있음. 이를 스플릿 브레인이라 함. 매우 위험한 상황.
- 리더가 분명하게 죽었다고 판단 가능한 적절한 타임아웃은 어느정도인지도 애매모호함. 너무 길면 그만큼 복구 시간이 길어짐. 반대로 너무 짧다면 불필요한 페일오버가 일어날 수 있음.

### 복제 로그 구현

#### 구문 기반 복제

- 리더는 모든 쓰기 요청(statement)을 기록하고 쓰기 실행 후 로그를 팔로워에 전송. 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행.
- NOW(), RAND()와 같은 비결정적 함수 호출은 각 노드마다 다른 값을 생성할 가능성이 있음.
- 해결책은 리더에서 비결정적 함수 호출할때 고정 값을 반환하도록 하여 팔로워에 전송. 하지만 다양한 엣지 케이스가 있음.

#### 쓰기 전 로그 배송

- WAL(Write-ahead logging) 과 같은 로그를 기록하는 시점에 팔로워에게 전송.
- 이 방식의 가장 큰 단점은 로그가 가장 저수준의 데이터를 기술한다는 것.
- 즉 해당 로그는 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함하는데 이는 복제가 저장소 엔진과 밀접하게 엮임. 따라서 데이터베이스 소프트웨어 버전 등에 영향을 받을 수 있음. 예컨대 데이터베이스 소프트웨어 버전을 업그레이드 하기 위해 서비스를 중단해야 할수도.

#### 논리적(로우기반) 로그 복제

- 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안
- 복제를 위해 다른 로그 형식을 사용. 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고도 부름.
- 논리적 로그 형식은 외부 애플리케이션에서 더 파싱하기 쉬움. 이는 사용자 정의 색인과 캐시 구축을 위해 데이터웨어하우스 같은 곳에 내용을 전송할 때 유용함. 이런 기술을 변경 데이터 캡처 라고 함.

#### 트리거 기반 복제

- 앞선 방식들은 애플리케이션 코드 없이 데이터베이스 시스템에 의해 구축 됨.
- 앞선 방식들 보다 버그나 제한 사항이 더 많지만 조금 더 유연성이 필요한 경우 예컨대 데이터베이스를 다른 종류 데이터베이스로 복제하거나 데이터의 서브셋만 복제하는 경우 유용함.


## 복제 지연 문제

비동기 팔로워에서 데이터를 읽을때 데이터 불일치가 발생할 수 있음. 비동기 복제 역시 최종적 일관성이 적용됨. 복제 지연이 있을 때 발생할 수 있는 사례들은 다음과 같음.

- 자신이 리더에 쓰기 수행 후 팔로워에서 읽기시 복제 지연으로 읽을 수 없음.
- 시간이 거꾸로 흐름. 여러 팔로워가 있고 아직 하나의 팔로워에만 복제 된 상황에서 한 사용자가 두번의 요청을 보냄. 첫 요청은 복제 완료 된 팔로워, 두번째 요청은 복제 지연 된 팔로워에서 읽는 상황.
- 인과성의 위반. 예컨대 (A) 보통 10초 정도요 → (Q) 미래에 대해 얼마나 멀리 볼 수 있나요?

이러한 문제들을 용인하기 어려운 시스템이라면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템을 설계해야 함. 하지만 너무 복잡해서 잘못되기도 쉬움.

트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이지만 분산 데이터베이스에서는 어려움이 많음.


## 다중 리더 복제

리더 기반 복제의 단점은 하나의 리더에 문제가 생긴다면 쓰기를 할 수 없다는 것. 이를 위해 쓰기 허용 노드를 하나 이상 두는 방식인데 복잡도에 비해 이점이 크지 않기 때문에 다음과 같은 상황에 고려할만함.

- 다중 데이터센터 운영
- 오프라인 작업을 하는 클라이언트. 각 클라이언트에 리더처럼 동작하는 로컬 데이터베이스가 존재.

### 쓰기 충돌 다루기

다중 리더 복제의 가장 큰 문제는 역시 쓰기 충돌. 책에서 크게 4가지 방법이 제시되는데 어떤것도 쉽지 않아 보임.. 각자 상황에 따라 트레이드 오프를 선택해야 할 듯.

#### 동기 vs 비동기 충돌 감지

- 동기식 충돌 감지가 필요하다면 단일 리더를 사용하는 것이 나음.
- 이론적으로 다중 리더에서 충돌 감지를 동기식으로 만들 수 있긴 하지만 각 복제 서버가 독립적으로 쓰기를 허용하는 다중 리더 복제의 장점을 잃게 됨.

#### 충돌 회피

- 많은 다중 리더 복제 구현 사례에서 충돌을 잘 처리하지 못하기 때문에 충돌을 피하는 것이 권장 됨.
- 예컨대 특정 사용자의 요청은 특정 리더로만 라우팅함으로써 한 사용자 관점에서는 단일 리더가 되는 형태의 구현

#### 일관된 상태 수렴

- 단일 리더에서는 순차적인 쓰기를 적용하지만 다중 리더에서는 어떤 순서도 다른 순서보다 정확하지 않음.
- 각 쓰기에 고유 ID를 부여하거나 어떤 값 병합 알고리즘을 통해 수렴(convergent) 방식으로 충돌을 해소하고 모든 복제 서버에 최종 값을 전달.

#### 사용자 정의 충돌 해소 로직

- 애플리케이션에서 적합한 방법으로 충돌 해소 로직을 구현.

### 다중 리더 복제 토폴로지

- 복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명.
- 두 리더가 있다면 가능한 토폴로지가 하나뿐임.
- 반면 리더가 두개 이상이라면 원형, 별, 전체 연결 등의 토폴로지가 있음.


## 리더 없는 복제

### 노드가 다운됐을 때 데이터베이스에 쓰기

- 리더 없는 설정에서는 장애 복구가 필요하지 않음
- 세 개의 복제 노드가 있다고 가정했을 때 클라이언트는 세 개의 복제 노드에 병렬로 쓰기 요청 전송
- 두 개의 노드만 쓰기가 성공하고 정족수가 2일때 클라이언트는 쓰기를 성공으로 간주
- 이 때 쓰기를 실패했던 노드가 정상화되면 응답으로 오래된 데이터를 얻을 수 있는데, 클라이언트는 읽기 요청도 세 개 노드에 병렬로 보냄. 버전 번호를 사용해 어떤 값이 최신인지 결정

#### 읽기 복구와 안티 엔트로피

위 예와 같이 사용 불가능이었던 노드가 온라인 상태가 된 후 누락된 쓰기를 따라잡는 방법으로는 주로 두가지 메커니즘을 사용.

- 읽기복구: 클라이언트는 여러 노드에서 병렬 읽기를 수행 후 버전 번호 등으로 오래된 값을 판단. 오래된 값을 가진 복제 노드에는 새 값을 기록함. 읽기가 자주 발생하는 상황에 적합
- 안티엔트로피처리: 데이터스토어 노드에서 별도의 백그라운드 프로세스가 노드간 데이터 차이를 지속적으로 감지/복구

#### 읽기와 쓰기를 위한 정족수

- n개의 복제 노드가 있을때 쓰기는 w개에 성공, 질의는 최소 r개에 해야 함.
- w + r > n 이면 읽을 때 최신 값을 얻을 수 있을것을 기대할 수 있음.
- 일반적으로 n은 홀수로(3, 5..)로 하고 w = r = (n+1) / 2(반올림)  로 설정.
- 상황에 따라 위 숫자는 바꿀 수 있는데 예컨대 워크로드에서 쓰기가 적고 읽기가 많다면 w = n, r = 1 로 설정해도 좋음. 이렇게하면 읽기는 빨라지지만 노드 하나가 고장나면 모든 쓰기가 실패하는 트레이드오프.

![https://user-images.githubusercontent.com/13076271/92928706-738c8d80-f47a-11ea-84f0-eda35065c025.png](https://user-images.githubusercontent.com/13076271/92928706-738c8d80-f47a-11ea-84f0-eda35065c025.png)

### 정족수 일관성의 한계

- 앞서 w + r > n 이면 일반적으로 모든 읽기는 최신 값을 반환할 것을 기대함
- 하지만 여전히 몇가지 엣지 케이스는 존재 (P.183 참고)

### 느슨한 정족수와 암시된 핸드오프

- 적절히 설정된 정족수를 통해 일부 노드의 장애를 용인할 수 있음.
- 반면 정족수는 내결함성이 없음. 네트워크 중단등의 이슈로 클라이언트와 다수의 노드의 연결은 언제라도 일시적으로 끊어질 수 있음.
- 노드가 n개 이상인 대규모 클러스터에서 네트워크 장애 상황에 정족수 구성에 들어가지 않는 일부노드에는 연결이 될 가능성이 있음. 이 일부노드에 일단 쓰기를 수행하는것을 느슨한 정족수라고 함.
- 이 부분은 좀 헷갈림. 이때까지 n이 전체 노드를 뜻한걸로 알았는데 지정된 n보다 노드는 더 있을 수 있는 듯.
- 아무튼 이렇게 n에는 포함되지 않지만 쓰기를 수용가능한 노드에 쓴 후, w가 만족된다면 클라이언트에는 성공 응답을 주고 네트워크 장애가 복구됐을때 n에 포함된 노드들로 데이터 전송. 이를 암시된 핸드오프라 함.

### 동시 쓰기 감지

다양한 네트워크 지연과 부분적인 장애로 각 노드에 서로 다른 순서로 이벤트가 도착할 수 있음. 최종적인 일관성을 달성하기 위해 복제 노드들은 모두 동일한 값을 가져야 함.

이를 위한 방법들로 다음과 같은 기법을 소개. 여기서 정리는 안함.

- 최종 쓰기 승리 (동시 쓰기 버리기)
- 동시에 쓴 값 병합
- 버전벡터
