# 2020315
## 왜 리액티브인가?
- [리액티브 선언문](https://www.reactivemanifesto.org/ko)

예측 가능한 상황에서 시스템은 안정적으로 운영할 수 있지만 예측을 빗나가는 순간 시스템은 무너짐. 예컨대 소규모 스타트업 서비스가 방송에 노출되거나 어떤 이벤트로 급잡스레 부하가 증가하면 이는 예상을 벗어난 것.
예상 밖 상황에 대응하지 못하면 고객에게 신뢰를 잃고 우리 서비스를 떠나게 만듬. 그럼 어떻게 대응할 것인가?  변화에 대응할 수 있는 애플리케이션을 만들기 위한 방법 중 하나가 리액티브한 아키텍처.

![리액티브 선언문](https://www.reactivemanifesto.org/images/reactive-traits-ko.svg)
느슨하게 결합하기 위해 메세지 기반으로 동작하며 유연성과 탄력성을 확보해야 함. 이를 통해 이루고자 하는 핵심 가치는 응답성. 리액티브 선언문에서 응답성은 가능한 즉각적으로 응답하는 것이라고 정의함. [릴리즈잇](https://github.com/iamkyu/TIL/blob/master/books/summary/release-it.md) 에서는 이렇게 얘기 했음.

> 어떤 경우이든지, 그냥 답을 갖고 돌아오라. (중략) 나를 기다리게 만든다면 여러분이 작업을 끝내기 전에 나는 여러분의 사이트를 떠날지도 모른다.

# 20200130
## 부패하는 소프트웨어

> 운이 좋은 경우에는 원하는 시스템의 분명한 청사진을 가지고 프로젝트를 시작할 수 있다. (중략) 더 운이 좋다면, 명쾌한 설계를 첫 번째 릴리즈까지도 가능해질 것이다. 그러고 나면, 뭔가 잘못되기 시작한다. 소프트웨어는 상한 고기 조각처럼 부패하기 시작해서, 시간이 지남에 따라 부패 범위가 넓어지고 심해진다. 심하게 곪은 상처와 종기가 코드에 쌓이면서, 점점 유지보수하기가 어려워진다. 결국, 가장 단순한 변경을 위해 필요한 순수한 노력조차도 아주 귀찮은 일이 되버려서, 개발자와 일선 관리자는 재설계를 절실히 필요로 하게 된다. 그러나 이런 재설계는 성공하기 어렵다. (중략) 기존 시스템은 계속 발전하고 변경되며 새로운 설계는 그것을 쫓아가야 한다. 새로운 설계가 첫 번째 릴리즈에 이르기도 전에 혹과 궤양이 새로운 설계에 생기는 셈이다. - 클린소프트웨어. 로버트 C. 마틴 저. 이용원 외 2명 역. 제이펍. 2017

다음은 소프트웨어 개발에서 흔히 볼 수 있는 상황
1. 프로젝트 초기 깔끔하고 우아한 코드 설계
2. 새로운 기능의 추가와 변경사항의 구현
3. 코드는 더 이상 설계를 따르지 않고 일정을 따라잡기 위해 올바르게 끝내는 것과 빠르게 끝내는 것 사이에서 타협
4. 코드는 스파게티가 되고 ‘나중에 리팩터링해라’, ‘임시로 작성한 코드다.’, ‘나중에 더 나은 해결책이 떠 오를 것이다’와 같은 수 많은 주석만 쌓임
5. 점점 간단한 변경조차도 구현하는 비용이 커짐
6. 결국 재설계가 필요하다는 것을 관리자에게 알림

하지만 재 설계는 이 문제를 해결하지 못함. 미래를 알려주는 마법의 수정 구슬이 없다면 변화는 항상 예측할 수 없는 방향으로 이루어짐. 새로운 설계를 처음 릴리즈 할 때조차도, 이것은 단지 사이클의 또 다른 라운드의 시작에 불과 (모던 웹 애 플리케이션 개발. 제임스 J. 예 저. 김현만 외 2명 역. 위키북스. 2020).

근 몇년사이에 특정 시스템을 완전히 뒤엎는 프로젝트도 몇 번 참여했고 새 기능의 추가가 너무 어려운 상황의 코드에 단순 복사-붙여넣기로 때우기도, 굉장히 단순한 요구사항 조차 공수가 너무 많이 든다고 다시 고려해달라고 한 적이 있다.
왜 소프트웨어는 계속 부패하고 몇 년 주기로 갈아 엎을 수 밖에 없을까? 부패하지 않도록 치열하게 힘쓰는 비용과 몇 년 주기로 갈아엎는 비용 중 어느 것이 더 저렴할까?
계속해서 바뀌는 프로젝트 구성원, 그 구성원들간의 코드에 대한 수 많은 토론과 고민들, 작은 요구사항이라도 충분히 고민할 수 있는 일정 혹은 나중에라도 개선하는 책임감. 이런 것들이 결코 쉽지 않음을 느낀다.

