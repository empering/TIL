# 20191109
## Java, Call By Reference 에 대한 오해
조금 오해하고 있던 Call By Reference 에 대해 간단히 [정리](https://namkyujin.com/2019-11-09/java-call-by-reference/).


# 20191013
[코드스피츠 84 오브젝트2 - 6회차 Youtube](https://youtu.be/biJS1Ze8UMw) 를 시청함.
- 우리가 만드는 시스템의 목적을 명확히 이해해야 함. 시스템 목적의 변화는 아키텍처의 변경을 유발.
- 이 말인 즉 목적, 기능/비기능적 요구사항들이 아키텍처를 변하게 하는데 문제는 사용자도 정확한 요구사항을 모름. 시스템이 릴리즈 되고 난 후 실제 프로덕트를 봐야 피드백을 줄 수 있음.
- 따라서 우리는 CI/CD 를 통해서 사용자에게 프로덕트를 지속적으로 딜리버리 해야 함. 단순히 빌드 성공 여부를 확인하기 위해 CI/CD 를 하는 것은 아님. (둘은 다른 개념이긴 하지만..)
- 하지만 현실적으로 실무에서는 수 많은 이해 관계자와 절차, 규정이 존재 함. 또한, 기능 하나 배포의 파급 효과가 큼. 너무 많은 사용자에게 영향을 주기 때문에 두려움.
- 하지만 이건 조금 다른 이야기. 일단 CI/CD 할 수 있어야 하고 그 후 A/B 테스트를 하고 데이터를 측정하여 기능을 발전시켜갈 것인가 F/O 할 것인가를 결정.
- 이를 위해 프로덕트를 만들기 시작할 때 우리가 해야 하는 건 레이어링을 어떻게 해야 하고, 세부 알고리즘부터 작게 작게 구현하며 테스트 하는 게 아니라 모든 등장 인물이(외부 DB, API 등)  포함되어 실제 서버 위에서 한 사이클이 완전히 동작하는 골격 코드를 작성. 이를 사용자에게 전달하고 피드백을 얻음. 그리고 아키텍처를 개선.
- 굉장히 이상적이지만 이렇게 하기 힘들게 만드는건 어떤것들일까?


# 20191003
## The Law of Leaky Abstractions
- [the-law-of-leaky-abstractions](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions)

"추상화라는 것은 우리에게 드러나서 일어나는 일 아래에서 훨씬 더 복잡하게 일어나고 있는 것들에 대한 단순화"라고 함. 실제로 현대의 애플리케이션 개발은 굉장히 높은 수준에서 이뤄지고 있음. 하지만 다양하게 응용하고 복잡한 문제를 해결하다 보면 결국 그 추상화 단계 아래로 내려갈 수 밖에 없음. 저자 역시 "추상화 아래 숨겨진 복잡함이 완벽히 감춰질 수는 없다" 고 함.
추상화가 있는 곳은 항상 이런 누출이 일어날 수 밖에 없는데 이에 대응하는 방법은 결국, 추상화 아래에서 어떻게 작동하고 추상화 되는지에 대해 배우는 것. 추상화는 우리의 개발 시간을 절약 해주지만 배우는 시간을 절약해주지는 않음.
